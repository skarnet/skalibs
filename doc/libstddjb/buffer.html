<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Language" content="en" />
    <title>skalibs: the buffer header</title>
    <meta name="Description" content="skalibs: the buffer header" />
    <meta name="Keywords" content="skalibs header buffer buffering stdio" />
    <!-- <link rel="stylesheet" type="text/css" href="//skarnet.org/default.css" /> -->
  </head>
<body>

<p>
<a href="index.html">libstddjb</a><br />
<a href="../libskarnet.html">libskarnet</a><br />
<a href="../index.html">skalibs</a><br />
<a href="//skarnet.org/software/">Software</a><br />
<a href="//skarnet.org/">skarnet.org</a>
</p>

<h1> The <tt>buffer</tt> library interface </h1>

<p>
 The following functions are declared in the <tt>skalibs/buffer.h<tt> header,
and implemented in the <tt>libskarnet.a</tt> or <tt>libskarnet.so</tt> library.
</p>

<h2> General information </h2>

<p>
 skalibs provides convenience structures and functions to perform buffered I/O.
These structures and functions abstract direct calls to <tt>read</tt> or <tt>write</tt>;
they're meant to be used in place of <tt>stdio.h</tt> primitives. Unlike <tt>stdio</tt>,
they can be used with non-blocking file descriptors.
</p>

<p>
 A buffer is a structure containing the following fields:
</p>

<ul>
 <li> <em>op</em>: a pointer to a function performing I/O. This is the function
that will be called anytime the buffer needs to acquire (or flush) data to its
underlying fd. </li>
 <li> <em>fd</em>: the fd from which data will be read or written. </li>
 <li> <em>c</em>: a circular buffer used to store data. </li>
</ul>

<p>
 Users should not need to interact directly with any of these fields. They are
initialized by <tt>buffer_init</tt> or <tt>BUFFER_INIT</tt>. Ulterior
interactions with the buffer should only be done with the various dedicated
functions.
</p>

<h2> Functions </h2>

<p>
<code> ssize_t buffer_put (buffer *b, char const *buf, size_t len) </code> <br />
Write the <em>len</em> bytes pointed to by <em>buf</em> to buffer <em>b</em>.
Returns the number of bytes written if it succeeds, or -1 and sets errno if it
fails.
</p>

<p>
<code> ssize_t buffer_puts (buffer *b, char const *s) </code> <br />
Write the string <em>s</em>, terminating nul-byte excepted, to buffer <em>b</em>.
Returns the number of bytes written if it succeeds, or -1 and sets errno if it
fails.
</p>

<p>
<code> int buffer_flush(buffer *b) </code> <br />
Flushes the buffer <em>b</em>.
Returns 1 if it succeeds, 0 and sets errno if it fails.
</p>

<p>
<code> ssize_t buffer_get (buffer *b, char *s, size_t len) </code> <br />
Read <em>len</em> bytes from buffer <em>b</em> and write them into <em>s</em>.
Retuns the number of bytes read if it succeeds, or -1 and sets errno if it
fails.
</p>

<p>
 The above are the most important and fundamental functions for buffering.
Other functions can be found in the same header and their prototypes are
self-explaining. More may be documented here later.
</p>

</body>
</html>
